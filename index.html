<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>霓虹流光姓名展示</title>
  <style>
    :root {
      --neon-color: hsl(240, 100%, 50%);
      --neon-pink: hsl(310, 100%, 50%);
      --neon-blue: hsl(210, 100%, 50%);
      --neon-purple: hsl(280, 100%, 50%);
      --neon-green: hsl(120, 100%, 50%);
      --beam-primary: hsl(220, 100%, 60%);
      --beam-secondary: hsl(280, 100%, 60%);
    }

    body {
      margin: 0;
      padding: 0;
      background-color: #000;
      background-image: 
        radial-gradient(circle at 10% 20%, rgba(137, 102, 255, 0.05) 0%, transparent 20%),
        radial-gradient(circle at 80% 30%, rgba(255, 69, 255, 0.05) 0%, transparent 25%),
        radial-gradient(circle at 30% 70%, rgba(64, 224, 208, 0.05) 0%, transparent 30%);
      overflow: hidden;
      font-family: 'Arial', sans-serif;
      position: relative;
    }

    /* 全屏霓虹闪动效果 */
    .neon-flash-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      pointer-events: none;
      z-index: 20;
      overflow: hidden;
    }

    /* 底部中心光线效果容器 */
    .bottom-beam-container {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      pointer-events: none;
      z-index: 15;
      overflow: hidden;
    }

    /* 中心光线主光束 */
    .center-beam {
      position: absolute;
      bottom: 0;
      left: 50%;
      width: 3px;
      height: 50vh;
      background: var(--beam-primary, hsl(220, 100%, 60%));
      border-radius: 10px;
      transform: translateX(-50%);
      z-index: 16;
      animation: beam-up 0.7s ease-out forwards;
      will-change: transform, opacity;
    }

    /* 光线爆炸形成的圆形 */
    .beam-circle {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 300px;
      height: 300px;
      border: 3px solid var(--beam-secondary, hsl(280, 100%, 60%));
      border-radius: 50%;
      transform: translate(-50%, -50%) scale(0);
      z-index: 16;
      opacity: 0.8;
      animation: beam-circle-expand 0.8s ease-out forwards 0.7s;
    }

    /* 光线爆炸的粒子 */
    .beam-particle {
      position: absolute;
      top: 50%;
      left: 50%;
      background: var(--beam-primary, hsl(220, 100%, 60%));
      border-radius: 50%;
      transform: translate(-50%, -50%);
      z-index: 17;
      filter: blur(0.5px);
      will-change: transform, opacity;
    }

    /* 霓虹光束 */
    .neon-beam {
      position: absolute;
      opacity: 0;
      pointer-events: none;
      background: linear-gradient(90deg, transparent, currentColor, transparent);
      filter: blur(2px);
      animation: beam-flash 5s infinite;
    }

    /* 霓虹脉冲 */
    .neon-pulse {
      position: absolute;
      width: 200vw;
      height: 200vh;
      top: -50%;
      left: -50%;
      border-radius: 50%;
      background: radial-gradient(circle, transparent 60%, var(--neon-color) 70%, transparent 80%);
      opacity: 0;
      pointer-events: none;
      animation: pulse-flash 8s infinite;
    }

    /* 霓虹区域 */
    .neon-area {
      position: absolute;
      opacity: 0;
      background: var(--neon-color);
      filter: blur(50px);
      animation: area-flash 4s infinite;
      mix-blend-mode: screen;
    }

    /* 霓虹光线 */
    .neon-ray {
      position: absolute;
      height: 1px;
      background: linear-gradient(90deg, transparent, var(--neon-color), transparent);
      opacity: 0;
      filter: blur(1px);
      animation: ray-flash 3s infinite;
    }

    /* 霓虹闪光效果动画 */
    @keyframes beam-flash {
      0%, 100% { opacity: 0; transform: scale(0.8); }
      10% { opacity: 0.4; transform: scale(1); }
      20% { opacity: 0; transform: scale(1.2); }
      50% { opacity: 0; }
      60% { opacity: 0.3; transform: scale(0.9); }
      70% { opacity: 0; transform: scale(1.1); }
    }

    @keyframes pulse-flash {
      0%, 100% { opacity: 0; transform: scale(0.5); }
      30% { opacity: 0.1; transform: scale(0.8); }
      50% { opacity: 0; transform: scale(1); }
      70% { opacity: 0.15; transform: scale(0.7); }
    }

    @keyframes area-flash {
      0%, 100% { opacity: 0; }
      20% { opacity: 0.05; }
      40% { opacity: 0; }
      60% { opacity: 0.03; }
      80% { opacity: 0; }
    }

    @keyframes ray-flash {
      0%, 100% { opacity: 0; width: 0; }
      25% { opacity: 0.3; width: 200px; }
      50% { opacity: 0; width: 300px; }
    }

    /* 底部中心光线向上动画 */
    @keyframes beam-up {
      0% {
        transform: translateX(-50%) scaleY(0);
        opacity: 1;
        height: 0;
      }
      70% {
        opacity: 1;
        height: 50vh;
      }
      100% {
        transform: translateX(-50%) scaleY(1);
        opacity: 0;
        height: 50vh;
      }
    }

    /* 光线爆炸成圆形动画 */
    @keyframes beam-circle-expand {
      0% {
        transform: translate(-50%, -50%) scale(0);
        opacity: 0;
        border-width: 4px;
      }
      40% {
        opacity: 1;
        border-width: 3px;
      }
      80% {
        opacity: 0.6;
      }
      100% {
        transform: translate(-50%, -50%) scale(1.2);
        opacity: 0;
        border-width: 1px;
      }
    }

    /* 光线爆炸粒子动画 */
    @keyframes beam-particle-explode {
      0% {
        transform: translate(-50%, -50%) scale(0);
        opacity: 0;
      }
      10% {
        opacity: 1;
      }
      50% {
        opacity: 0.8;
      }
      100% {
        transform: translate(0, 0) scale(0.5);
        opacity: 0;
      }
    }

    #name-container {
      position: relative;
      width: 100vw;
      height: 100vh;
    }

    .center-glow {
      position: fixed;
      top: 50%;
      left: 50%;
      width: 300px;
      height: 300px;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, rgba(0,0,0,0) 70%);
      transform: translate(-50%, -50%);
      pointer-events: none;
    }

    /* 霓虹背景网格 */
    .neon-grid {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background-image: 
        linear-gradient(rgba(137, 102, 255, 0.05) 1px, transparent 1px),
        linear-gradient(90deg, rgba(137, 102, 255, 0.05) 1px, transparent 1px);
      background-size: 30px 30px;
      pointer-events: none;
      animation: grid-float 60s ease-in-out infinite;
    }

    /* 霓虹线条 */
    .neon-line {
      position: fixed;
      height: 1px;
      background: linear-gradient(90deg, transparent, var(--neon-color), transparent);
      opacity: 0.4;
      animation: line-float 30s linear infinite;
    }

    /* 烟花容器 */
    #fireworks-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      pointer-events: none;
      z-index: 10;
      overflow: hidden;
      will-change: contents;
    }

    /* 烟花效果 */
    .firework {
      position: fixed;
      width: 5px;
      height: 5px;
      border-radius: 50%;
      opacity: 0;
      pointer-events: none;
    }

    .firework-particle {
      position: absolute;
      width: 4px;
      height: 4px;
      border-radius: 50%;
      opacity: 1;
      pointer-events: none;
      box-shadow: 0 0 10px currentColor, 0 0 20px currentColor, 0 0 30px currentColor;
    }

    /* 动画定义 */
    @keyframes grid-float {
      0%, 100% {
        transform: translate(0, 0);
      }
      50% {
        transform: translate(30px, 30px);
      }
    }

    @keyframes line-float {
      0% {
        transform: translateX(-100%);
      }
      100% {
        transform: translateX(200%);
      }
    }

    @keyframes firework-explode {
      0% {
        transform: scale(0);
        opacity: 1;
      }
      20% {
        transform: scale(var(--particle-distance));
        opacity: 1;
      }
      100% {
        transform: scale(var(--particle-distance));
        opacity: 0;
      }
    }

    @keyframes firework-fade {
      0% {
        opacity: 1;
      }
      100% {
        opacity: 0;
      }
    }

    .name-element {
      position: absolute;
      font-size: 72px;
      font-weight: bold;
      white-space: nowrap;
      transform-origin: center;
      opacity: 0;
      will-change: transform, opacity;
      display: flex;
      align-items: center;
      background: none !important;
      border: none !important;
      outline: none !important;
      box-shadow: none !important;
      padding: 0;
      margin: 0;
    }

    /* 增强的流星尾迹效果 */
    .name-trail {
      position: absolute;
      height: 3px;
      background: linear-gradient(to right, transparent, var(--neon-color), transparent);
      border-radius: 2px;
      opacity: 0.8;
      pointer-events: none;
      transform-origin: right center;
      z-index: -1;
      box-shadow: 0 0 5px var(--neon-color), 0 0 10px var(--neon-color);
      animation: trail-fade 0.5s linear forwards;
      max-width: 300px;
    }

    .neon-text {
      color: #fff;
      text-shadow: 
        0 0 2px #fff,
        0 0 5px #fff,
        0 0 10px var(--neon-color),
        0 0 20px var(--neon-color),
        0 0 30px var(--neon-color),
        0 0 40px var(--neon-color);
      animation: flicker 2s infinite alternate;
      border: none !important;
      outline: none !important;
      box-shadow: none !important;
    }

    @keyframes flicker {
      0%, 19.999%, 22%, 62.999%, 64%, 64.999%, 70%, 100% {
        opacity: 1;
        text-shadow: 
          0 0 2px #fff,
          0 0 5px #fff,
          0 0 10px var(--neon-color),
          0 0 20px var(--neon-color),
          0 0 30px var(--neon-color),
          0 0 40px var(--neon-color);
      }
      20%, 21.999%, 63%, 63.999%, 65%, 69.999% {
        opacity: 0.6;
        text-shadow: 
          0 0 1px #fff,
          0 0 2px #fff,
          0 0 5px var(--neon-color),
          0 0 10px var(--neon-color);
      }
    }

    /* 流星尾迹淡出动画 */
    @keyframes trail-fade {
      0% {
        width: 200px;
        opacity: 0.9;
        transform: translateY(-50%) scale(1);
      }
      50% {
        width: 250px;
        opacity: 0.5;
        transform: translateY(-50%) scale(0.9);
      }
      100% {
        width: 350px;
        opacity: 0;
        transform: translateY(-50%) scale(0.8);
      }
    }

    @keyframes floatAnimation {
      0% {
        transform: translate(calc(var(--start-x)), calc(var(--start-y))) scale(0.3);
        opacity: 0;
        filter: blur(2px);
      }
      10% {
        opacity: 1;
        filter: blur(0px);
      }
      90% {
        opacity: 1;
        filter: blur(0px);
      }
      100% {
        transform: translate(calc(var(--end-x)), calc(var(--end-y))) scale(0.3);
        opacity: 0;
        filter: blur(2px);
      }
    }
  </style>
</head>
<body>
  <!-- 霓虹背景元素 -->
  <div class="neon-grid"></div>
  <div class="neon-lines-container"></div>
  <div id="fireworks-container"></div>
  
  <!-- 主要内容 -->
  <div id="name-container"></div>
  <div class="center-glow"></div>
  
  <script>
    const familyNames = [
      '王俊杰', '唐雪涵', '张洲', '张静', '张冲',
      '唐旗', '唐文思', '罗尹', '郑十一', '王十二'
    ];

    function getRandomEdgePosition() {
      const startEdge = Math.floor(Math.random() * 4);
      const endEdge = (startEdge + 2) % 4;
      let startX, startY, targetX, targetY;
      
      switch(startEdge) {
        case 0: // 上边
          startX = Math.random() * window.innerWidth;
          startY = -50;
          targetX = Math.random() * window.innerWidth * 0.5 + window.innerWidth * 0.25;
          targetY = window.innerHeight + 50;
          break;
        case 1: // 右边
          startX = window.innerWidth + 50;
          startY = Math.random() * window.innerHeight;
          targetX = -50;
          targetY = Math.random() * window.innerHeight * 0.5 + window.innerHeight * 0.25;
          break;
        case 2: // 下边
          startX = Math.random() * window.innerWidth;
          startY = window.innerHeight + 50;
          targetX = Math.random() * window.innerWidth * 0.5 + window.innerWidth * 0.25;
          targetY = -50;
          break;
        case 3: // 左边
          startX = -50;
          startY = Math.random() * window.innerHeight;
          targetX = window.innerWidth + 50;
          targetY = Math.random() * window.innerHeight * 0.5 + window.innerHeight * 0.25;
          break;
      }
      
      return {
        x: `${startX}px`,
        y: `${startY}px`,
        targetX: `${targetX}px`,
        targetY: `${targetY}px`
      };
    }

    function createTrailElement(element, color) {
      const trail = document.createElement('div');
      trail.classList.add('name-trail');
      trail.style.setProperty('--neon-color', color);
      trail.style.left = '100%';
      trail.style.top = '50%';
      trail.style.transform = 'translateY(-50%)';
      trail.style.height = '3px';
      trail.style.opacity = '0.8';
      trail.style.boxShadow = `0 0 5px ${color}, 0 0 10px ${color}`;
      return trail;
    }

    let trailsAnimationFrame;
    let lastUpdateTime = 0;
    const TRAIL_UPDATE_INTERVAL = 100;

    function updateTrails() {
      const now = performance.now();
      
      if (now - lastUpdateTime < TRAIL_UPDATE_INTERVAL) {
        trailsAnimationFrame = requestAnimationFrame(updateTrails);
        return;
      }
      
      lastUpdateTime = now;
      
      const nameElements = document.querySelectorAll('.name-element');
      const maxElementsPerFrame = 10;
      const elementsToProcess = Array.from(nameElements).slice(0, maxElementsPerFrame);
      
      elementsToProcess.forEach(element => {
        const style = window.getComputedStyle(element);
        const transform = style.transform;
        
        let rotation = 0;
        try {
          const matrix = new DOMMatrix(transform);
          rotation = Math.atan2(matrix.b, matrix.a) * (180 / Math.PI);
        } catch (e) {
          const matrixMatch = transform.match(/matrix\(([^)]+)\)/);
          if (matrixMatch) {
            const matrixValues = matrixMatch[1].split(', ');
            if (matrixValues.length >= 6) {
              rotation = Math.atan2(parseFloat(matrixValues[1]), parseFloat(matrixValues[0])) * (180 / Math.PI);
            }
          }
        }
        
        const hue = element.style.getPropertyValue('--neon-color');
        const trail = createTrailElement(element, hue);
        
        trail.style.transform = `translateY(-50%) rotate(${rotation}deg)`;
        
        element.appendChild(trail);
        
        const trails = element.querySelectorAll('.name-trail');
        if (trails.length > 2) {
          trails[0].remove();
        }
      });
      
      trailsAnimationFrame = requestAnimationFrame(updateTrails);
    }

    function createNameElement(name) {
      const element = document.createElement('div');
      element.classList.add('name-element', 'neon-text');
      element.textContent = name;
      
      const position = getRandomEdgePosition();
      
      const duration = 4 + Math.random() * 10; // 4-14秒，降低为原来的一半速度
      const delay = Math.random() * 2; // 0-2秒，降低出现频率为原来的一半
      const hue = Math.floor(Math.random() * 360);
      
      element.style.setProperty('--start-x', position.x);
      element.style.setProperty('--start-y', position.y);
      element.style.setProperty('--end-x', position.targetX);
      element.style.setProperty('--end-y', position.targetY);
      element.style.setProperty('--neon-color', `hsl(${hue}, 100%, 50%)`);
      element.style.animation = `floatAnimation ${duration}s linear ${delay}s infinite`;
      element.style.animationDuration = `${duration}s`;
      element.style.animationDelay = `${delay}s`;
      
      element.style.boxShadow = `0 0 10px hsl(${hue}, 100%, 50%), 0 0 20px hsl(${hue}, 100%, 50%)`;
      
      const startX = parseFloat(position.x);
      const startY = parseFloat(position.y);
      const endX = parseFloat(position.targetX);
      const endY = parseFloat(position.targetY);
      
      const angle = Math.atan2(endY - startY, endX - startX) * (180 / Math.PI);
      element.style.transform = `rotate(${angle}deg)`;
      
      return element;
    }

    function spawnNameElements(count = 5) { // 降低默认生成数量为原来的一半
      const container = document.getElementById('name-container');
      
      for (let i = 0; i < count; i++) {
        const randomName = familyNames[Math.floor(Math.random() * familyNames.length)];
        const element = createNameElement(randomName);
        
        enhanceNameElement(element);
        
        container.appendChild(element);
      }
    }

    function handleResize() {
      const container = document.getElementById('name-container');
      container.style.width = `${window.innerWidth}px`;
      container.style.height = `${window.innerHeight}px`;
      
      const elements = document.querySelectorAll('.name-element');
      elements.forEach(element => {
        const startX = parseFloat(element.style.getPropertyValue('--start-x')) / 100;
        const startY = parseFloat(element.style.getPropertyValue('--start-y')) / 100;
        const endX = parseFloat(element.style.getPropertyValue('--end-x')) / 100;
        const endY = parseFloat(element.style.getPropertyValue('--end-y')) / 100;
        
        element.style.setProperty('--start-x', `${startX * 100}vw`);
        element.style.setProperty('--start-y', `${startY * 100}vh`);
        element.style.setProperty('--end-x', `${endX * 100}vw`);
        element.style.setProperty('--end-y', `${endY * 100}vh`);
        
        const computedStyle = window.getComputedStyle(element);
        const animation = computedStyle.animation;
        element.style.animation = 'none';
        element.offsetHeight;
        element.style.animation = animation;
      });
    }

    function setupMouseInteractions() {
      const container = document.getElementById('name-container');
      
      container.addEventListener('mousemove', function(e) {
        const elements = document.querySelectorAll('.name-element');
        elements.forEach(element => {
          const rect = element.getBoundingClientRect();
          const centerX = rect.left + rect.width / 2;
          const centerY = rect.top + rect.height / 2;
          
          const distanceX = e.clientX - centerX;
          const distanceY = e.clientY - centerY;
          const distance = Math.sqrt(distanceX * distanceX + distanceY * distanceY);
          
          if (distance < 100) {
            const offsetX = (distanceX / distance) * (100 - distance) * 0.1;
            const offsetY = (distanceY / distance) * (100 - distance) * 0.1;
            element.style.transform = element.style.transform.replace(/ translate\([^)]*\)/g, '') + ` translate(${offsetX}px, ${offsetY}px)`;
          }
        });
      });
      
      container.addEventListener('click', function() {
        const randomName = familyNames[Math.floor(Math.random() * familyNames.length)];
        const element = createNameElement(randomName);
        container.appendChild(element);
        
        element.addEventListener('animationend', function() {
          container.removeChild(element);
        });
      });
    }

    function setupTouchInteractions() {
      const container = document.getElementById('name-container');
      let isTouched = false;
      
      container.addEventListener('touchstart', function(e) {
        isTouched = true;
        const randomName = familyNames[Math.floor(Math.random() * familyNames.length)];
        const element = createNameElement(randomName);
        container.appendChild(element);
        
        element.addEventListener('animationend', function() {
          container.removeChild(element);
        });
        
        e.preventDefault();
      });
      
      container.addEventListener('touchmove', function(e) {
        if (!isTouched) return;
        
        const touch = e.touches[0];
        const elements = document.querySelectorAll('.name-element');
        elements.forEach(element => {
          const rect = element.getBoundingClientRect();
          const centerX = rect.left + rect.width / 2;
          const centerY = rect.top + rect.height / 2;
          
          const distanceX = touch.clientX - centerX;
          const distanceY = touch.clientY - centerY;
          const distance = Math.sqrt(distanceX * distanceX + distanceY * distanceY);
          
          if (distance < 100) {
            const offsetX = (distanceX / distance) * (100 - distance) * 0.1;
            const offsetY = (distanceY / distance) * (100 - distance) * 0.1;
            element.style.transform = element.style.transform.replace(/ translate\([^)]*\)/g, '') + ` translate(${offsetX}px, ${offsetY}px)`;
          }
        });
        
        e.preventDefault();
      });
      
      container.addEventListener('touchend', function() {
        isTouched = false;
      });
    }

    function init() {
      handleResize();
      window.addEventListener('resize', handleResize);
      spawnNameElements(7); // 降低元素数量为原来的一半
      setupMouseInteractions();
      setupTouchInteractions();
      
      setInterval(updateTrails, 100);
    }

    function createNeonLines() {
      const container = document.querySelector('.neon-lines-container');
      const linesCount = 8;
      
      for (let i = 0; i < linesCount; i++) {
        const line = document.createElement('div');
        line.classList.add('neon-line');
        
        const top = Math.random() * 100;
        const width = Math.random() * 300 + 100;
        const delay = Math.random() * 10;
        const duration = Math.random() * 20 + 20;
        const hue = Math.floor(Math.random() * 360);
        
        line.style.top = `${top}vh`;
        line.style.width = `${width}px`;
        line.style.setProperty('--neon-color', `hsl(${hue}, 100%, 50%)`);
        line.style.animation = `line-float ${duration}s linear ${delay}s infinite`;
        
        container.appendChild(line);
      }
    }

    function createNeonFlashes() {
      let flashContainer = document.querySelector('.neon-flash-container');
      if (!flashContainer) {
        flashContainer = document.createElement('div');
        flashContainer.classList.add('neon-flash-container');
        document.body.appendChild(flashContainer);
      }
      
      const beamCount = 15;
      const beamColors = ['var(--neon-pink)', 'var(--neon-blue)', 'var(--neon-purple)', 'var(--neon-green)'];
      
      for (let i = 0; i < beamCount; i++) {
        const beam = document.createElement('div');
        beam.classList.add('neon-beam');
        
        const orientation = Math.random() > 0.5 ? 'horizontal' : 'vertical';
        const color = beamColors[Math.floor(Math.random() * beamColors.length)];
        const delay = Math.random() * 5;
        
        if (orientation === 'horizontal') {
          beam.style.width = `${Math.random() * 60 + 40}vw`;
          beam.style.height = `${Math.random() * 2 + 1}px`;
          beam.style.left = `${Math.random() * 100}vw`;
          beam.style.top = `${Math.random() * 100}vh`;
          beam.style.transform = 'translateX(-50%)';
        } else {
          beam.style.width = `${Math.random() * 2 + 1}px`;
          beam.style.height = `${Math.random() * 60 + 40}vh`;
          beam.style.left = `${Math.random() * 100}vw`;
          beam.style.top = `${Math.random() * 100}vh`;
          beam.style.transform = 'translateY(-50%)';
        }
        
        beam.style.color = color;
        beam.style.animationDelay = `${delay}s`;
        
        flashContainer.appendChild(beam);
      }
      
      const pulseCount = 3;
      for (let i = 0; i < pulseCount; i++) {
        const pulse = document.createElement('div');
        pulse.classList.add('neon-pulse');
        
        const color = beamColors[Math.floor(Math.random() * beamColors.length)];
        const delay = Math.random() * 8;
        
        pulse.style.setProperty('--neon-color', color);
        pulse.style.animationDelay = `${delay}s`;
        
        flashContainer.appendChild(pulse);
      }
      
      const areaCount = 10;
      for (let i = 0; i < areaCount; i++) {
        const area = document.createElement('div');
        area.classList.add('neon-area');
        
        const size = Math.random() * 300 + 100;
        const color = beamColors[Math.floor(Math.random() * beamColors.length)];
        const delay = Math.random() * 4;
        
        area.style.width = `${size}px`;
        area.style.height = `${size}px`;
        area.style.left = `${Math.random() * 100}vw`;
        area.style.top = `${Math.random() * 100}vh`;
        area.style.transform = 'translate(-50%, -50%)';
        area.style.setProperty('--neon-color', color);
        area.style.animationDelay = `${delay}s`;
        
        flashContainer.appendChild(area);
      }
      
      const rayCount = 20;
      for (let i = 0; i < rayCount; i++) {
        const ray = document.createElement('div');
        ray.classList.add('neon-ray');
        
        const length = Math.random() * 100 + 50;
        const angle = Math.random() * 360;
        const color = beamColors[Math.floor(Math.random() * beamColors.length)];
        const delay = Math.random() * 3;
        
        ray.style.width = `${length}px`;
        ray.style.left = `${Math.random() * 100}vw`;
        ray.style.top = `${Math.random() * 100}vh`;
        ray.style.transform = `rotate(${angle}deg)`;
        ray.style.setProperty('--neon-color', color);
        ray.style.animationDelay = `${delay}s`;
        
        flashContainer.appendChild(ray);
      }
      
      setInterval(() => {
        const beams = flashContainer.querySelectorAll('.neon-beam');
        const randomBeams = Array.from(beams).sort(() => 0.5 - Math.random()).slice(0, 3);
        
        randomBeams.forEach(beam => {
          const color = beamColors[Math.floor(Math.random() * beamColors.length)];
          beam.style.color = color;
          beam.style.animation = 'none';
          beam.offsetHeight;
          beam.style.animation = `beam-flash 5s infinite ${Math.random() * 5}s`;
        });
        
        const rays = flashContainer.querySelectorAll('.neon-ray');
        const randomRays = Array.from(rays).sort(() => 0.5 - Math.random()).slice(0, 5);
        
        randomRays.forEach(ray => {
          const color = beamColors[Math.floor(Math.random() * beamColors.length)];
          const angle = Math.random() * 360;
          ray.style.setProperty('--neon-color', color);
          ray.style.transform = `rotate(${angle}deg)`;
        });
      }, 10000);
    }

    function createFirework(x, y) {
      const container = document.getElementById('fireworks-container');
      if (!container) return;
      
      const particleCount = 60;
      const colors = [
        'hsl(0, 100%, 50%)',
        'hsl(45, 100%, 50%)',
        'hsl(60, 100%, 50%)',
        'hsl(120, 100%, 50%)',
        'hsl(240, 100%, 50%)',
        'hsl(300, 100%, 50%)'
      ];
      const fireworkColor = colors[Math.floor(Math.random() * colors.length)];
      
      for (let i = 0; i < particleCount; i++) {
        const particle = document.createElement('div');
        particle.classList.add('firework-particle');
        
        const angle = (i / particleCount) * Math.PI * 2 + (Math.random() * 0.1 - 0.05);
        const distance = Math.random() * 200 + 150;
        const duration = Math.random() * 1.2 + 1.0;
        
        particle.style.left = `${x}px`;
        particle.style.top = `${y}px`;
        particle.style.backgroundColor = fireworkColor;
        particle.style.width = '4px';
        particle.style.height = '4px';
        particle.style.borderRadius = '50%';
        particle.style.opacity = '1';
        particle.style.boxShadow = `0 0 10px ${fireworkColor}, 0 0 20px ${fireworkColor}, 0 0 30px ${fireworkColor}`;
        particle.style.setProperty('--particle-distance', distance);
        particle.style.transformOrigin = `${x}px ${y}px`;
        particle.style.transform = `rotate(${angle}rad) scale(0)`;
        particle.style.position = 'absolute';
        
        particle.style.animation = `firework-explode ${duration}s ease-out forwards`;
        
        container.appendChild(particle);
        
        setTimeout(() => {
          if (container && container.contains(particle)) {
            container.removeChild(particle);
          }
        }, duration * 1000);
      }
    }

    function enhanceNameElement(element) {
      element.style.background = 'none';
      element.style.border = 'none';
      element.style.outline = 'none';
      element.style.boxShadow = 'none';
      
      const duration = parseFloat(element.style.animationDuration);
      const delay = parseFloat(element.style.animationDelay);
      
      let checkPosition = () => {
        if (!document.contains(element)) return;
        
        const rect = element.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        
        const screenCenterX = window.innerWidth / 2;
        const screenCenterY = window.innerHeight / 2;
        const distanceToCenter = Math.sqrt(
          Math.pow(centerX - screenCenterX, 2) + 
          Math.pow(centerY - screenCenterY, 2)
        );
        
        if (distanceToCenter < window.innerWidth / 4) {
          createFirework(centerX, centerY);
          return;
        }
        
        requestAnimationFrame(checkPosition);
      };
      
      setTimeout(() => {
        checkPosition();
      }, delay * 1000);
    }

    function createClickParticles(x, y) {
      const container = document.getElementById('name-container');
      
      const particleCount = 40;
      
      const particleColors = [
        'hsl(0, 100%, 50%)',
        'hsl(45, 100%, 50%)',
        'hsl(60, 100%, 50%)',
        'hsl(120, 100%, 50%)',
        'hsl(240, 100%, 50%)',
        'hsl(300, 100%, 50%)',
        'hsl(330, 100%, 50%)'
      ];
      
      for (let i = 0; i < particleCount; i++) {
        const particle = document.createElement('div');
        
        particle.style.position = 'absolute';
        particle.style.left = `${x}px`;
        particle.style.top = `${y}px`;
        particle.style.width = `${Math.random() * 4 + 2}px`;
        particle.style.height = `${Math.random() * 4 + 2}px`;
        particle.style.borderRadius = '50%';
        particle.style.pointerEvents = 'none';
        
        const color = particleColors[Math.floor(Math.random() * particleColors.length)];
        particle.style.backgroundColor = color;
        particle.style.boxShadow = `0 0 6px ${color}, 0 0 12px ${color}`;
        
        container.appendChild(particle);
        
        const angle = Math.random() * Math.PI * 2;
        const distance = Math.random() * 80 + 30;
        const velocityX = Math.cos(angle) * distance;
        const velocityY = Math.sin(angle) * distance;
        
        const duration = Math.random() * 0.5 + 0.8;
        
        const keyframes = [
          { opacity: 1, transform: 'translate(0, 0) scale(1)' },
          { opacity: 0.7, transform: `translate(${velocityX * 0.7}px, ${velocityY * 0.7}px) scale(0.8)` },
          { opacity: 0.3, transform: `translate(${velocityX * 0.9}px, ${velocityY * 0.9}px) scale(0.6)` },
          { opacity: 0, transform: `translate(${velocityX}px, ${velocityY}px) scale(0.3)` }
        ];
        
        particle.animate(keyframes, {
          duration: duration * 1000,
          easing: 'cubic-bezier(0.17, 0.55, 0.55, 1)',
          fill: 'forwards'
        });
        
        setTimeout(() => {
          if (container.contains(particle)) {
            container.removeChild(particle);
          }
        }, duration * 1000);
      }
    }

    function enhanceInteractions() {
      const container = document.getElementById('name-container');
      
      container.addEventListener('click', function(e) {
        createFirework(e.clientX, e.clientY);
        createClickParticles(e.clientX, e.clientY);
        
        const namesToAdd = Math.floor(Math.random() * 3) + 2;
        for (let i = 0; i < namesToAdd; i++) {
          const randomName = familyNames[Math.floor(Math.random() * familyNames.length)];
          const element = createNameElement(randomName);
          element.style.transform += ` translate(${Math.random() * 20 - 10}px, ${Math.random() * 20 - 10}px)`;
          container.appendChild(element);
          enhanceNameElement(element);
        }
      });
      
      container.addEventListener('touchstart', function(e) {
        const touch = e.touches[0];
        createFirework(touch.clientX, touch.clientY);
        createClickParticles(touch.clientX, touch.clientY);
        
        const namesToAdd = Math.floor(Math.random() * 3) + 2;
        for (let i = 0; i < namesToAdd; i++) {
          const randomName = familyNames[Math.floor(Math.random() * familyNames.length)];
          const element = createNameElement(randomName);
          element.style.transform += ` translate(${Math.random() * 20 - 10}px, ${Math.random() * 20 - 10}px)`;
          container.appendChild(element);
          enhanceNameElement(element);
        }
      });
    }

    function startRandomFireworks() {
      setInterval(() => {
        const centerBias = 0.6;
        const edgeBias = 0.4;
        
        let x, y;
        if (Math.random() < centerBias) {
          x = window.innerWidth * 0.3 + Math.random() * window.innerWidth * 0.4;
          y = window.innerHeight * 0.3 + Math.random() * window.innerHeight * 0.4;
        } else {
          x = Math.random() * window.innerWidth;
          y = Math.random() * window.innerHeight;
        }
        
        createFirework(x, y);
      }, 1000);
    }

    function createBottomBeamEffect() {
      let beamContainer = document.querySelector('.bottom-beam-container');
      if (!beamContainer) {
        beamContainer = document.createElement('div');
        beamContainer.classList.add('bottom-beam-container');
        document.body.appendChild(beamContainer);
      }
      
      function createMainBeam() {
        const beamCount = Math.floor(Math.random() * 3) + 1;
        const beams = [];
        
        for (let i = 0; i < beamCount; i++) {
          const beam = document.createElement('div');
          beam.classList.add('center-beam');
          
          const fireworkColors = [
            'hsl(0, 100%, 60%)',
            'hsl(30, 100%, 60%)',
            'hsl(60, 100%, 60%)',
            'hsl(120, 100%, 60%)',
            'hsl(210, 100%, 60%)',
            'hsl(270, 100%, 60%)',
            'hsl(330, 100%, 60%)'
          ];
          
          const randomColor = fireworkColors[Math.floor(Math.random() * fireworkColors.length)];
          beam.style.backgroundColor = randomColor;
          
          beam.style.boxShadow = `0 0 15px ${randomColor}, 0 0 30px ${randomColor}, 0 0 45px ${randomColor}`;
          
          const beamWidth = Math.random() * 3 + 2;
          beam.style.width = `${beamWidth}px`;
          
          const angleOffset = (i - Math.floor(beamCount / 2)) * (Math.random() * 2 + 1);
          beam.style.transform = `translateX(-50%) rotate(${angleOffset}deg)`;
          
          const delay = Math.random() * 0.2 + (i * 0.05);
          beam.style.animationDelay = `${delay}s`;
          
          beamContainer.appendChild(beam);
          beams.push({
            element: beam,
            beamWidth
          });
          
          let lastTime = 0;
          let jitterDirection = 1;
          let currentJitter = 0;
          
          function jitter(timestamp) {
            if (!document.contains(beam)) return;
            
            if (!lastTime) lastTime = timestamp;
            const deltaTime = timestamp - lastTime;
            
            if (deltaTime > 50) {
              jitterDirection = Math.random() > 0.5 ? jitterDirection : -jitterDirection;
              currentJitter = Math.min(4, Math.abs(currentJitter) + (Math.random() * 1.5));
              const jitterX = currentJitter * jitterDirection;
              
              beam.style.transform = `translateX(calc(-50% + ${jitterX}px)) rotate(${angleOffset}deg)`;
              lastTime = timestamp;
            }
            
            requestAnimationFrame(jitter);
          }
          
          setTimeout(() => {
            requestAnimationFrame(jitter);
          }, 200);
          
          setTimeout(() => {
            if (beamContainer && beamContainer.contains(beam)) {
              beam.animate([
                { opacity: 1, width: `${beamWidth}px`, height: '50vh' },
                { opacity: 0.8, width: `${beamWidth * 1.2}px`, height: '45vh' },
                { opacity: 0, width: `${beamWidth * 0.3}px`, height: '30vh' }
              ], {
                duration: 400,
                easing: 'cubic-bezier(0.7, 0, 0.84, 0)',
                fill: 'forwards'
              });
              
              setTimeout(() => {
                if (beamContainer && beamContainer.contains(beam)) {
                  beamContainer.removeChild(beam);
                }
              }, 400);
            }
          }, 3000 + (i * 200));
        }
        
        createSparks(beamCount);
        
        return beams;
      }
      
      function createSparks(beamCount) {
        const sparkCount = beamCount * 20;
        
        for (let i = 0; i < sparkCount; i++) {
          const spark = document.createElement('div');
          spark.classList.add('beam-particle');
          
          const size = Math.random() * 2 + 1;
          spark.style.width = `${size}px`;
          spark.style.height = `${size}px`;
          
          spark.style.bottom = '10px';
          spark.style.left = '50%';
          
          const colors = ['hsl(0, 100%, 70%)', 'hsl(30, 100%, 70%)', 'hsl(60, 100%, 70%)'];
          const color = colors[Math.floor(Math.random() * colors.length)];
          spark.style.backgroundColor = color;
          spark.style.boxShadow = `0 0 8px ${color}`;
          
          const angle = (Math.random() - 0.5) * Math.PI * 0.4;
          const distance = Math.random() * 100 + 50;
          const x = Math.cos(angle) * distance;
          const y = -Math.sin(angle) * distance;
          
          beamContainer.appendChild(spark);
          
          const duration = Math.random() * 0.5 + 0.3;
          const delay = Math.random() * 0.5;
          
          setTimeout(() => {
            spark.animate([
              { opacity: 0, transform: 'translate(-50%, 0) scale(0)' },
              { opacity: 1, transform: 'translate(-50%, 0) scale(1)' },
              { opacity: 0.7, transform: `translate(calc(-50% + ${x * 0.7}px), ${y * 0.7}px) scale(0.8)` },
              { opacity: 0, transform: `translate(calc(-50% + ${x}px), ${y}px) scale(0.3)` }
            ], {
              duration: duration * 1000,
              easing: 'ease-out',
              fill: 'forwards'
            });
            
            setTimeout(() => {
              if (beamContainer && beamContainer.contains(spark)) {
                beamContainer.removeChild(spark);
              }
            }, duration * 1000);
          }, delay * 1000);
        }
      }
      
      function createExplosionCircle() {
        const circle = document.createElement('div');
        circle.classList.add('beam-circle');
        
        const fireworkColors = [
          'hsl(0, 100%, 50%)',
          'hsl(30, 100%, 50%)',
          'hsl(60, 100%, 50%)',
          'hsl(120, 100%, 50%)',
          'hsl(210, 100%, 50%)',
          'hsl(270, 100%, 50%)',
          'hsl(330, 100%, 50%)'
        ];
        
        const randomColor = fireworkColors[Math.floor(Math.random() * fireworkColors.length)];
        circle.style.borderColor = randomColor;
        
        circle.style.boxShadow = `0 0 20px ${randomColor}, 0 0 30px ${randomColor}`;
        
        const size = Math.random() * 200 + 200;
        circle.style.width = `${size}px`;
        circle.style.height = `${size}px`;
        
        const borderWidth = Math.random() * 3 + 2;
        circle.style.borderWidth = `${borderWidth}px`;
        
        circle.style.opacity = Math.random() * 0.3 + 0.7;
        
        const delay = 0.6 + Math.random() * 0.3;
        circle.style.animationDelay = `${delay}s`;
        
        beamContainer.appendChild(circle);
        
        const pulseInterval = setInterval(() => {
          const scale = 0.95 + Math.random() * 0.1;
          circle.style.transform = `translate(-50%, -50%) scale(${scale})`;
        }, 100);
        
        setTimeout(() => {
          clearInterval(pulseInterval);
          if (beamContainer && beamContainer.contains(circle)) {
            beamContainer.removeChild(circle);
          }
        }, 2500);
        
        return circle;
      }
      
      function createExplosionParticles() {
        const baseParticleCount = 60;
        const screenFactor = (window.innerWidth * window.innerHeight) / (1920 * 1080);
        const particleCount = Math.floor(baseParticleCount * screenFactor);
        
        const fireworkColors = [
          'hsl(0, 100%, 50%)',
          'hsl(30, 100%, 50%)',
          'hsl(60, 100%, 50%)',
          'hsl(120, 100%, 50%)',
          'hsl(210, 100%, 50%)',
          'hsl(270, 100%, 50%)',
          'hsl(330, 100%, 50%)'
        ];
        
        const particles = [];
        
        for (let i = 0; i < particleCount; i++) {
          const particle = document.createElement('div');
          particle.classList.add('beam-particle');
          particles.push(particle);
        }
        
        particles.forEach(particle => {
          beamContainer.appendChild(particle);
        });
        
        particles.forEach((particle, i) => {
          const size = Math.random() * 6 + 2;
          particle.style.width = `${size}px`;
          particle.style.height = `${size}px`;
          
          const waveCount = Math.floor(Math.random() * 2) + 1;
          const baseAngle = (i / particleCount) * Math.PI * 2;
          const angleVariation = (Math.random() - 0.5) * 0.6;
          const angle = baseAngle + angleVariation;
          
          const distance = Math.random() * 300 + 200;
          const x = Math.cos(angle) * distance;
          const y = Math.sin(angle) * distance;
          
          const particleDuration = Math.random() * 0.7 + 1.3;
          const startOffset = Math.random() * 0.15;
          
          const hasSecondaryBurst = Math.random() > 0.7;
          
          const randomColor = fireworkColors[Math.floor(Math.random() * fireworkColors.length)];
          particle.style.backgroundColor = randomColor;
          particle.style.boxShadow = `0 0 15px ${randomColor}, 0 0 30px ${randomColor}`;
          
          const delay = 0.7 + Math.random() * 0.3;
          
          setTimeout(() => {
            particle.animate([
              { opacity: 0, transform: 'translate(-50%, -50%) scale(0)' },
              { opacity: 1, transform: `translate(calc(-50% + ${x * 0.3}px), calc(-50% + ${y * 0.3}px)) scale(1)` },
              { opacity: 0.8, transform: `translate(calc(-50% + ${x * 0.7}px), calc(-50% + ${y * 0.7}px)) scale(1)` },
              { opacity: 0, transform: `translate(calc(-50% + ${x}px), calc(-50% + ${y}px)) scale(0.5)` }
            ], {
              duration: particleDuration * 1000,
              easing: 'cubic-bezier(0.17, 0.55, 0.55, 1)',
              fill: 'forwards'
            });
            
            if (hasSecondaryBurst) {
              setTimeout(() => {
                const burstCount = 3;
                for (let j = 0; j < burstCount; j++) {
                  const burstParticle = document.createElement('div');
                  burstParticle.classList.add('beam-particle');
                  burstParticle.style.width = '3px';
                  burstParticle.style.height = '3px';
                  burstParticle.style.backgroundColor = randomColor;
                  burstParticle.style.boxShadow = `0 0 10px ${randomColor}, 0 0 20px ${randomColor}`;
                  burstParticle.style.left = '50%';
                  burstParticle.style.top = '50%';
                  
                  beamContainer.appendChild(burstParticle);
                  
                  const burstAngle = angle + (Math.random() - 0.5) * Math.PI;
                  const burstDistance = Math.random() * 50 + 30;
                  const burstX = Math.cos(burstAngle) * burstDistance;
                  const burstY = Math.sin(burstAngle) * burstDistance;
                  
                  burstParticle.animate([
                    { opacity: 0, transform: `translate(calc(-50% + ${x * 0.5}px), calc(-50% + ${y * 0.5}px)) scale(0)` },
                    { opacity: 1, transform: `translate(calc(-50% + ${x * 0.5 + burstX}px), calc(-50% + ${y * 0.5 + burstY}px)) scale(1)` },
                    { opacity: 0, transform: `translate(calc(-50% + ${x * 0.5 + burstX * 1.5}px), calc(-50% + ${y * 0.5 + burstY * 1.5}px)) scale(0.3)` }
                  ], {
                    duration: 500,
                    easing: 'cubic-bezier(0.17, 0.55, 0.55, 1)',
                    fill: 'forwards'
                  });
                  
                  setTimeout(() => {
                    if (beamContainer && beamContainer.contains(burstParticle)) {
                      beamContainer.removeChild(burstParticle);
                    }
                  }, 500);
                }
              }, particleDuration * 1000 * 0.5);
            }
            
            setTimeout(() => {
              if (beamContainer && beamContainer.contains(particle)) {
                beamContainer.removeChild(particle);
              }
            }, particleDuration * 1000);
          }, delay * 1000);
        });
      }
      
      function playBeamSequence() {
        // 随机延迟启动光束序列，使效果更自然
        setTimeout(() => {
          // 创建主光束
          createMainBeam();
          
          // 延迟创建爆炸圆形
          setTimeout(() => {
            createExplosionCircle();
          }, 800);
          
          // 延迟创建爆炸粒子
          setTimeout(() => {
            createExplosionParticles();
          }, 1000);
          
          // 循环播放序列
          setTimeout(playBeamSequence, 5000 + Math.random() * 10000); // 5-15秒随机间隔
        }, 2000 + Math.random() * 8000); // 初始延迟2-10秒
      }
      
      playBeamSequence();
    }

    function enhancedInit() {
      // 性能优化：优先加载视觉效果元素
      const container = document.getElementById('name-container');
      
      // 延迟加载一些非关键功能
      setTimeout(() => {
        createNeonLines();
        createNeonFlashes();
      }, 500);
      
      // 延迟启动光束效果
      setTimeout(() => {
        createBottomBeamEffect();
      }, 1000);
      
      // 延迟启动随机烟花
      setTimeout(() => {
        startRandomFireworks();
      }, 2000);
      
      // 批量处理元素增强，避免一次性处理过多DOM
      setTimeout(() => {
        const elements = document.querySelectorAll('.name-element');
        
        // 分批处理增强
        let processed = 0;
        const batchSize = 3;
        
        function processBatch() {
          const batch = Array.from(elements).slice(processed, processed + batchSize);
          if (batch.length === 0) return;
          
          batch.forEach(element => {
            enhanceNameElement(element);
          });
          
          processed += batch.length;
          
          // 使用requestAnimationFrame避免阻塞主线程
          requestAnimationFrame(() => {
            setTimeout(processBatch, 100);
          });
        }
        
        processBatch();
      }, 1500);
      
      // 添加交互增强
      enhanceInteractions();
      
      // 监听页面可见性变化，优化性能
      document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
          // 暂停动画和计时器等
          if (trailsAnimationFrame) {
            cancelAnimationFrame(trailsAnimationFrame);
          }
        } else {
          // 恢复动画
          updateTrails();
        }
      });
      
      // 初始更新流线
      updateTrails();
    }

    // 页面加载完成后初始化
    window.addEventListener('DOMContentLoaded', function() {
      init();
      enhancedInit();
    });
  </script>
</body>
</html>